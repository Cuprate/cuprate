//! Block Verifier Service.
use std::{
    collections::HashSet,
    future::Future,
    pin::Pin,
    sync::Arc,
    task::{Context, Poll},
};

use cuprate_helper::asynch::rayon_spawn_async;
use futures::FutureExt;
use monero_serai::{
    block::Block,
    transaction::{Input, Transaction},
};
use rayon::prelude::*;
use tower::{Service, ServiceExt};
use tracing::{instrument, trace};

use cuprate_consensus_rules::blocks::RX_SEEDHASH_EPOCH_BLOCKS;
use cuprate_consensus_rules::{
    blocks::{
        calculate_pow_hash, check_block, check_block_pow, is_randomx_seed_height,
        randomx_seed_height, BlockError, RandomX,
    },
    miner_tx::MinerTxError,
    ConsensusError, HardFork,
};

use crate::{
    context::{
        rx_vms::RandomXVM, BlockChainContextRequest, BlockChainContextResponse,
        RawBlockChainContext,
    },
    transactions::{
        batch_setup_txs, contextual_data, OutputCache, TransactionVerificationData,
        VerifyTxRequest, VerifyTxResponse,
    },
    Database, ExtendedConsensusError,
};

/// A pre-prepared block with all data except the proof of work hash.
#[derive(Debug)]
struct PrePreparedBlockExPOW {
    /// The block
    pub block: Block,
    /// The serialised blocks bytes
    pub block_blob: Vec<u8>,

    /// The blocks hf vote
    pub hf_vote: HardFork,
    /// The blocks hf version
    pub hf_version: HardFork,

    /// The blocks hash
    pub block_hash: [u8; 32],
    /// The blocks height
    pub height: u64,

    /// The weight of the blocks miner transaction.
    pub miner_tx_weight: usize,
}

impl PrePreparedBlockExPOW {
    /// Creates a [`PrePreparedBlockExPOW`] from a [`Block`]
    pub fn new(block: Block) -> Result<PrePreparedBlockExPOW, ConsensusError> {
        let (hf_version, hf_vote) =
            HardFork::from_block_header(&block.header).map_err(BlockError::HardForkError)?;

        let Some(Input::Gen(height)) = block.miner_tx.prefix.inputs.first() else {
            Err(ConsensusError::Block(BlockError::MinerTxError(
                MinerTxError::InputNotOfTypeGen,
            )))?
        };

        // We can call this now we know the height.
        trace!("Setting up PrePreparedBlockExPOW for block: {}", height);

        Ok(PrePreparedBlockExPOW {
            block_blob: block.serialize(),
            hf_vote,
            hf_version,

            block_hash: block.hash(),
            height: *height,

            miner_tx_weight: block.miner_tx.weight(),
            block,
        })
    }
}

/// A pre-prepared block with all data needed to verify it.
#[derive(Debug)]
pub struct PrePreparedBlock {
    /// The block
    pub block: Block,
    /// The serialised blocks bytes
    pub block_blob: Vec<u8>,

    /// The blocks hf vote
    pub hf_vote: HardFork,
    /// The blocks hf version
    pub hf_version: HardFork,

    /// The blocks hash
    pub block_hash: [u8; 32],
    /// The blocks POW hash.
    pub pow_hash: [u8; 32],

    /// The weight of the blocks miner transaction.
    pub miner_tx_weight: usize,
}

impl PrePreparedBlock {
    /// Creates a new [`PrePreparedBlock`].
    ///
    /// The randomX VM must be Some if RX is needed or this will panic.
    /// The randomX VM must also be initialised with the correct seed.
    fn new<R: RandomX>(
        block: PrePreparedBlockExPOW,
        randomx_vm: Option<&R>,
    ) -> Result<PrePreparedBlock, ConsensusError> {
        let Some(Input::Gen(height)) = block.block.miner_tx.prefix.inputs.first() else {
            Err(ConsensusError::Block(BlockError::MinerTxError(
                MinerTxError::InputNotOfTypeGen,
            )))?
        };

        Ok(PrePreparedBlock {
            block_blob: block.block_blob,
            hf_vote: block.hf_vote,
            hf_version: block.hf_version,

            block_hash: block.block_hash,
            pow_hash: calculate_pow_hash(
                randomx_vm,
                &block.block.serialize_hashable(),
                *height,
                &block.hf_version,
            )?,

            miner_tx_weight: block.miner_tx_weight,
            block: block.block,
        })
    }
}

/// Information about a verified block.
#[derive(Debug)]
pub struct VerifiedBlockInformation {
    /// The block that has been verified.
    pub block: Block,
    /// The block's hard-fork vote.
    pub hf_vote: HardFork,
    /// The txs in this block.
    pub txs: Vec<Arc<TransactionVerificationData>>,
    /// The blocks hash.
    pub block_hash: [u8; 32],
    /// the blocks POW hash.
    pub pow_hash: [u8; 32],
    /// The blocks height.
    pub height: u64,
    /// The amount of coins generated by this block.
    pub generated_coins: u64,
    /// This blocks wight.
    pub weight: usize,
    /// This blocks long term weight.
    pub long_term_weight: usize,
    /// The cumulative difficulty of the chain including this block.
    pub cumulative_difficulty: u128,
}

/// A request to verify a block, or to prepare a block for verification.
pub enum VerifyBlockRequest {
    /// A request to batch the setup of verification data.
    /// Will return [`VerifyBlockResponse::MainChainBatchPrep`], which you can then call
    /// [`VerifyBlockRequest::MainChainPrepared`] to finish the verification.
    ///
    /// The amount of blocks that are being batch set-up should not be too large as if *any* are
    /// incorrect a lot of work could be wasted. There is a hard limit of the length of a RX seed window
    /// (2048 blocks) and this will panic if more than this many blocks is passed in.
    ///
    /// It is not valid to call this more than once and keep the batches around to pass into [`VerifyBlockRequest::MainChainPrepared`]
    /// later.
    MainChainBatchPrep(Vec<(Block, Vec<Transaction>)>),
    /// A request to verify a block.
    MainChain {
        block: Block,
        prepared_txs: Vec<Arc<TransactionVerificationData>>,
        txs: Vec<Transaction>,
    },
    /// A request to verify a block that has already been prepared.
    MainChainPrepared(PrePreparedBlock, Vec<Arc<TransactionVerificationData>>),
}

/// A response from a verify block request.
pub enum VerifyBlockResponse {
    /// This block is valid.
    MainChain(VerifiedBlockInformation),
    /// These blocks have been batch prepared successfully but may not be valid.
    MainChainBatchPrep(
        Vec<PrePreparedBlock>,
        Vec<Vec<Arc<TransactionVerificationData>>>,
    ),
}

/// The block verifier service.
pub struct BlockVerifierService<C, TxV, D> {
    /// The context service.
    context_svc: C,
    /// The tx verifier service.
    tx_verifier_svc: TxV,
    /// The database.
    database: D,
}

impl<C, TxV, D> BlockVerifierService<C, TxV, D>
where
    C: Service<BlockChainContextRequest, Response = BlockChainContextResponse>
        + Clone
        + Send
        + 'static,
    TxV: Service<VerifyTxRequest, Response = VerifyTxResponse, Error = ExtendedConsensusError>
        + Clone
        + Send
        + 'static,
    D: Database + Clone + Send + Sync + 'static,
    D::Future: Send + 'static,
{
    /// Creates a new block verifier.
    pub(crate) fn new(
        context_svc: C,
        tx_verifier_svc: TxV,
        database: D,
    ) -> BlockVerifierService<C, TxV, D> {
        BlockVerifierService {
            context_svc,
            tx_verifier_svc,
            database,
        }
    }
}

impl<C, TxV, D> Service<VerifyBlockRequest> for BlockVerifierService<C, TxV, D>
where
    C: Service<
            BlockChainContextRequest,
            Response = BlockChainContextResponse,
            Error = tower::BoxError,
        > + Clone
        + Send
        + 'static,
    C::Future: Send + 'static,

    TxV: Service<VerifyTxRequest, Response = VerifyTxResponse, Error = ExtendedConsensusError>
        + Clone
        + Send
        + 'static,
    TxV::Future: Send + 'static,

    D: Database + Clone + Send + Sync + 'static,
    D::Future: Send + 'static,
{
    type Response = VerifyBlockResponse;
    type Error = ExtendedConsensusError;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: VerifyBlockRequest) -> Self::Future {
        let context_svc = self.context_svc.clone();
        let tx_verifier_svc = self.tx_verifier_svc.clone();
        let database = self.database.clone();

        async move {
            match req {
                VerifyBlockRequest::MainChain {
                    block,
                    prepared_txs,
                    txs,
                } => {
                    verify_main_chain_block(block, txs, prepared_txs, context_svc, tx_verifier_svc)
                        .await
                }
                VerifyBlockRequest::MainChainPrepared(prepped_block, txs) => {
                    verify_main_chain_block_prepared(
                        prepped_block,
                        txs,
                        context_svc,
                        tx_verifier_svc,
                        None,
                    )
                    .await
                }
                VerifyBlockRequest::MainChainBatchPrep(blocks) => {
                    batch_prepare_main_chain_block(blocks, context_svc, database).await
                }
            }
        }
        .boxed()
    }
}

/// Batches the setup of multiple blocks.
#[instrument(level = "info", name = "batch_prep_blocks", skip_all)]
async fn batch_prepare_main_chain_block<C, D>(
    blocks: Vec<(Block, Vec<Transaction>)>,
    mut context_svc: C,
    mut database: D,
) -> Result<VerifyBlockResponse, ExtendedConsensusError>
where
    C: Service<
            BlockChainContextRequest,
            Response = BlockChainContextResponse,
            Error = tower::BoxError,
        > + Send
        + 'static,
    C::Future: Send + 'static,
    D: Database + Clone + Send + Sync + 'static,
    D::Future: Send + 'static,
{
    assert!((blocks.len() as u64) < RX_SEEDHASH_EPOCH_BLOCKS);

    tracing::debug!("preparing {} blocks for verification.", blocks.len());

    let (blocks, txs): (Vec<_>, Vec<_>) = blocks.into_iter().unzip();

    tracing::debug!("Setting up PrePreparedBlockExPOW for blocks");
    let blocks: Vec<PrePreparedBlockExPOW> = rayon_spawn_async(|| {
        blocks
            .into_iter()
            .map(PrePreparedBlockExPOW::new)
            .collect::<Result<Vec<_>, _>>()
    })
    .await?;

    let mut timestamps_hfs = Vec::with_capacity(blocks.len());
    let mut new_rx_vm = None;

    // Make sure each block's parent is the block before it.
    for window in blocks.windows(2) {
        if window[0].block_hash != window[1].block.header.previous
            || window[0].height != window[1].height - 1
        {
            tracing::debug!(
                "Block {} does not have expected parent {} or correct stated height",
                hex::encode(window[1].block_hash),
                hex::encode(window[0].block_hash)
            );

            Err(ConsensusError::Block(BlockError::PreviousIDIncorrect))?;
        }

        // While we are looping over the blocks check if one of the blocks is a RX seed
        if is_randomx_seed_height(window[0].height) {
            // cache it if it is.
            new_rx_vm = Some((window[0].height, window[0].block_hash));
        }

        // Keep track of the blocks timestamp and hf.
        timestamps_hfs.push((window[0].block.header.timestamp, window[0].hf_version))
    }

    // Get the current blockchain context.

    tracing::debug!("getting blockchain context");
    let BlockChainContextResponse::Context(checked_context) = context_svc
        .ready()
        .await?
        .call(BlockChainContextRequest::GetContext)
        .await?
    else {
        panic!("Context service returned wrong response!");
    };

    // Batch get the required difficulties for these blocks.

    let BlockChainContextResponse::BatchDifficulties(difficulties) = context_svc
        .ready()
        .await?
        .call(BlockChainContextRequest::BatchGetDifficulties(
            timestamps_hfs,
        ))
        .await?
    else {
        panic!("Context service returned wrong response!");
    };

    let context = checked_context.unchecked_blockchain_context().clone();

    // make sure the first block is the expected height.
    if context.chain_height != blocks[0].height {
        Err(ConsensusError::Block(BlockError::MinerTxError(
            MinerTxError::InputsHeightIncorrect,
        )))?;
    }

    // make sure the first block has the correct parent.
    if context.top_hash != blocks[0].block.header.previous {
        Err(ConsensusError::Block(BlockError::PreviousIDIncorrect))?;
    }

    // get the RX VM map.
    let mut rx_vms = context.rx_vms;

    // Check if we found a RX seed in these blocks earlier
    if let Some((new_vm_height, new_vm_seed)) = new_rx_vm {
        tracing::debug!("New RX seed in blocks, setting up VM.");

        // If we did, set up the RX VM.
        let new_vm = rayon_spawn_async(move || {
            Arc::new(RandomXVM::new(&new_vm_seed).expect("RandomX VM gave an error on set up!"))
        })
        .await;

        // and give it to the context service to cache so we don't have to create it again.
        context_svc
            .ready()
            .await?
            .call(BlockChainContextRequest::NewRXVM((
                new_vm_seed,
                new_vm.clone(),
            )))
            .await?;

        // insert it in our map, so we can use it.
        rx_vms.insert(new_vm_height, new_vm);
    }

    // Compute the POW hashes and make sure they pass the required difficulty.
    tracing::debug!("Computing PoW hashes for blocks.");

    let blocks = rayon_spawn_async(move || {
        blocks
            .into_par_iter()
            .zip(difficulties)
            .map(|(block, difficultly)| {
                let height = block.height;

                trace!("Computing PoW hash for block: {}", height);

                let block = PrePreparedBlock::new(
                    block,
                    rx_vms.get(&randomx_seed_height(height)).map(AsRef::as_ref),
                )?;

                check_block_pow(&block.pow_hash, difficultly)?;
                Ok(block)
            })
            .collect::<Result<Vec<_>, ConsensusError>>()
    })
    .await?;

    // batch setup the txs (excluding ring member info).
    let txs = batch_setup_txs(
        // wrap each tx list with it's hf.
        txs.into_iter()
            .zip(blocks.iter().map(|block| block.hf_version))
            .collect(),
    )
    .await?;

    // Build the OutputCache, see its docs for info.
    let mut out_cache = OutputCache::new();
    out_cache
        .extend_from_block(
            blocks
                .iter()
                .map(|block| &block.block)
                .zip(txs.iter().map(Vec::as_slice)),
            &mut database,
        )
        .await?;

    tracing::debug!("Filling transaction ring members/ ring member info.");

    let mut complete_block_idx = 0;

    // loop over the blocks and find if there are any changes in HFs in the batch.
    for (idx, hf) in blocks
        .windows(2)
        .enumerate()
        .filter(|(_, block)| block[0].hf_version != blocks[1].hf_version)
        .map(|(i, block)| (i, &block[0].hf_version))
    {
        // Only batch prepare txs together if they are on the same HF.
        contextual_data::batch_fill_ring_member_info(
            txs.iter()
                .take(idx + 1)
                .skip(complete_block_idx)
                .flat_map(|txs| txs.iter()),
            hf,
            context.re_org_token.clone(),
            database.clone(),
            Some(&out_cache),
        )
        .await?;

        complete_block_idx = idx + 1;
    }

    // The last group of txs will always be skipped above so handle that now.
    if complete_block_idx != blocks.len() {
        contextual_data::batch_fill_ring_member_info(
            txs.iter()
                .skip(complete_block_idx)
                .flat_map(|txs| txs.iter()),
            &blocks.last().unwrap().hf_version,
            context.re_org_token.clone(),
            database.clone(),
            Some(&out_cache),
        )
        .await?;
    }

    tracing::debug!("batch setup complete.");

    Ok(VerifyBlockResponse::MainChainBatchPrep(blocks, txs))
}

/// Verifies a prepared block.
async fn verify_main_chain_block_prepared<C, TxV>(
    prepped_block: PrePreparedBlock,
    txs: Vec<Arc<TransactionVerificationData>>,
    context_svc: C,
    tx_verifier_svc: TxV,
    context: Option<RawBlockChainContext>,
) -> Result<VerifyBlockResponse, ExtendedConsensusError>
where
    C: Service<
            BlockChainContextRequest,
            Response = BlockChainContextResponse,
            Error = tower::BoxError,
        > + Send
        + 'static,
    C::Future: Send + 'static,
    TxV: Service<VerifyTxRequest, Response = VerifyTxResponse, Error = ExtendedConsensusError>,
{
    tracing::debug!("verifying block: {}", hex::encode(prepped_block.block_hash));

    // Allow reusing context.
    let context = match context {
        Some(context) => context,
        None => {
            tracing::debug!("getting blockchain context");
            let BlockChainContextResponse::Context(checked_context) = context_svc
                .oneshot(BlockChainContextRequest::GetContext)
                .await
                .map_err(Into::<ExtendedConsensusError>::into)?
            else {
                panic!("Context service returned wrong response!");
            };

            let context = checked_context.unchecked_blockchain_context().clone();

            tracing::debug!("got blockchain context: {:?}", context);
            context
        }
    };

    check_block_pow(&prepped_block.pow_hash, context.next_difficulty)
        .map_err(ConsensusError::Block)?;

    // Check that the txs included are what we need and that there are not any extra.

    let mut tx_hashes = txs.iter().map(|tx| &tx.tx_hash).collect::<HashSet<_>>();

    tracing::debug!("Checking we have correct transactions for block.");

    if tx_hashes.len() != txs.len() {
        return Err(ExtendedConsensusError::TxsIncludedWithBlockIncorrect);
    }

    for tx_hash in &prepped_block.block.txs {
        if !tx_hashes.remove(tx_hash) {
            return Err(ExtendedConsensusError::TxsIncludedWithBlockIncorrect);
        }
    }
    if !tx_hashes.is_empty() {
        return Err(ExtendedConsensusError::TxsIncludedWithBlockIncorrect);
    }

    tracing::debug!("Verifying transactions for block.");

    tx_verifier_svc
        .oneshot(VerifyTxRequest::Block {
            txs: txs.clone(),
            current_chain_height: context.chain_height,
            time_for_time_lock: context.current_adjusted_timestamp_for_time_lock(),
            hf: context.current_hf,
            re_org_token: context.re_org_token.clone(),
        })
        .await?;

    let block_weight =
        prepped_block.miner_tx_weight + txs.iter().map(|tx| tx.tx_weight).sum::<usize>();
    let total_fees = txs.iter().map(|tx| tx.fee).sum::<u64>();

    tracing::debug!("Verifying block header.");
    let (hf_vote, generated_coins) = check_block(
        &prepped_block.block,
        total_fees,
        block_weight,
        prepped_block.block_blob.len(),
        &context.context_to_verify_block,
    )
    .map_err(ConsensusError::Block)?;

    Ok(VerifyBlockResponse::MainChain(VerifiedBlockInformation {
        block_hash: prepped_block.block_hash,
        block: prepped_block.block,
        txs,
        pow_hash: prepped_block.pow_hash,
        generated_coins,
        weight: block_weight,
        height: context.chain_height,
        long_term_weight: context.next_block_long_term_weight(block_weight),
        hf_vote,
        cumulative_difficulty: context.cumulative_difficulty + context.next_difficulty,
    }))
}

/// Verifies a block that has not been prepared.
async fn verify_main_chain_block<C, TxV>(
    block: Block,
    txs: Vec<Transaction>,
    mut prepared_txs: Vec<Arc<TransactionVerificationData>>,
    mut context_svc: C,
    tx_verifier_svc: TxV,
) -> Result<VerifyBlockResponse, ExtendedConsensusError>
where
    C: Service<
            BlockChainContextRequest,
            Response = BlockChainContextResponse,
            Error = tower::BoxError,
        > + Send
        + 'static,
    C::Future: Send + 'static,
    TxV: Service<VerifyTxRequest, Response = VerifyTxResponse, Error = ExtendedConsensusError>,
{
    tracing::debug!("getting blockchain context");
    let BlockChainContextResponse::Context(checked_context) = context_svc
        .ready()
        .await?
        .call(BlockChainContextRequest::GetContext)
        .await
        .map_err(Into::<ExtendedConsensusError>::into)?
    else {
        panic!("Context service returned wrong response!");
    };

    let context = checked_context.unchecked_blockchain_context().clone();
    tracing::debug!("got blockchain context: {:?}", context);

    // Set up the block and just pass it to [`verify_main_chain_block_prepared`]

    let rx_vms = context.rx_vms.clone();
    let prepped_block = rayon_spawn_async(move || {
        let prepped_block_ex_pow = PrePreparedBlockExPOW::new(block)?;
        let height = prepped_block_ex_pow.height;

        PrePreparedBlock::new(prepped_block_ex_pow, rx_vms.get(&height).map(AsRef::as_ref))
    })
    .await?;

    // Altough this is checked in [`verify_main_chain_block_prepared`], check it now, so we don't waste time setting up txs.
    check_block_pow(&prepped_block.pow_hash, context.cumulative_difficulty)
        .map_err(ConsensusError::Block)?;

    prepared_txs.append(&mut batch_setup_txs(vec![(txs, context.current_hf)]).await?[0]);

    verify_main_chain_block_prepared(
        prepped_block,
        prepared_txs,
        context_svc,
        tx_verifier_svc,
        Some(context),
    )
    .await
}
